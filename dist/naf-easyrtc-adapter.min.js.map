{"version":3,"sources":["webpack:///webpack/bootstrap 8297db7d20ea3d0a1537","webpack:///./src/index.js"],"names":["EasyRtcAdapter","easyrtc","window","url","appName","roomName","options","successListener","occupantListener","openListener","clientSentTime","Date","document","method","cache","serverReceivedTime","res","precision","clientReceivedTime","timeOffset","setTimeout","Promise","_","clientId","client","media","NAF","dataType","roomOccupants","roomOccupant","destination","targetRoom","status","that","easyrtcid","audioEnabled","myRoomId","joinTime","module"],"mappings":"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","file":"naf-easyrtc-adapter.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8297db7d20ea3d0a1537","/* global NAF */\n\nclass EasyRtcAdapter {\n\n  constructor(easyrtc) {\n    this.easyrtc = easyrtc || window.easyrtc;\n    this.app = \"default\";\n    this.room = \"default\";\n\n    this.audioStreams = {};\n    this.pendingAudioRequest = {};\n\n    this.serverTimeRequests = 0;\n    this.timeOffsets = [];\n    this.avgTimeOffset = 0;\n  }\n\n  setServerUrl(url) {\n    this.easyrtc.setSocketUrl(url);\n  }\n\n  setApp(appName) {\n    this.app = appName;\n  }\n\n  setRoom(roomName) {\n    this.room = roomName;\n    this.easyrtc.joinRoom(roomName, null);\n  }\n\n  // options: { datachannel: bool, audio: bool }\n  setWebRtcOptions(options) {\n    // this.easyrtc.enableDebug(true);\n    this.easyrtc.enableDataChannels(options.datachannel);\n\n    this.easyrtc.enableVideo(false);\n    this.easyrtc.enableAudio(options.audio);\n\n    this.easyrtc.enableVideoReceive(false);\n    this.easyrtc.enableAudioReceive(true);\n  }\n\n  setServerConnectListeners(successListener, failureListener) {\n    this.connectSuccess = successListener;\n    this.connectFailure = failureListener;\n  }\n\n  setRoomOccupantListener(occupantListener) {\n    this.easyrtc.setRoomOccupantListener(function(\n      roomName,\n      occupants,\n      primary\n    ) {\n      occupantListener(occupants);\n    });\n  }\n\n  setDataChannelListeners(openListener, closedListener, messageListener) {\n    this.easyrtc.setDataChannelOpenListener(openListener);\n    this.easyrtc.setDataChannelCloseListener(closedListener);\n    this.easyrtc.setPeerListener(messageListener);\n  }\n\n  updateTimeOffset() {\n    const clientSentTime = Date.now() + this.avgTimeOffset;\n\n    return fetch(document.location.href, { method: \"HEAD\", cache: \"no-cache\" })\n      .then(res => {\n        var precision = 1000;\n        var serverReceivedTime = new Date(res.headers.get(\"Date\")).getTime() + (precision / 2);\n        var clientReceivedTime = Date.now();\n        var serverTime = serverReceivedTime + ((clientReceivedTime - clientSentTime) / 2);\n        var timeOffset = serverTime - clientReceivedTime;\n\n        this.serverTimeRequests++;\n\n        if (this.serverTimeRequests <= 10) {\n          this.timeOffsets.push(timeOffset);\n        } else {\n          this.timeOffsets[this.serverTimeRequests % 10] = timeOffset;\n        }\n\n        this.avgTimeOffset = this.timeOffsets.reduce((acc, offset) => acc += offset, 0) / this.timeOffsets.length;\n\n        if (this.serverTimeRequests > 10) {\n          setTimeout(() => this.updateTimeOffset(), 5 * 60 * 1000); // Sync clock every 5 minutes.\n        } else {\n          this.updateTimeOffset();\n        }\n      });\n  }\n\n  connect() {\n    Promise.all([\n      this.updateTimeOffset(),\n      new Promise((resolve, reject) => {\n        this._connect(this.easyrtc.audioEnabled, resolve, reject);\n      })\n    ]).then(([_, clientId]) => {\n      this._storeAudioStream(\n        this.easyrtc.myEasyrtcid,\n        this.easyrtc.getLocalStream()\n      );\n\n      this._myRoomJoinTime = this._getRoomJoinTime(clientId);\n      this.connectSuccess(clientId);\n    }).catch(this.connectFailure);\n  }\n\n  shouldStartConnectionTo(client) {\n    return this._myRoomJoinTime <= client.roomJoinTime;\n  }\n\n  startStreamConnection(clientId) {\n    this.easyrtc.call(\n      clientId,\n      function(caller, media) {\n        if (media === \"datachannel\") {\n          NAF.log.write(\"Successfully started datachannel to \", caller);\n        }\n      },\n      function(errorCode, errorText) {\n        NAF.log.error(errorCode, errorText);\n      },\n      function(wasAccepted) {\n        // console.log(\"was accepted=\" + wasAccepted);\n      }\n    );\n  }\n\n  closeStreamConnection(clientId) {\n    // Handled by easyrtc\n  }\n\n  sendData(clientId, dataType, data) {\n    // send via webrtc otherwise fallback to websockets\n    this.easyrtc.sendData(clientId, dataType, data);\n  }\n\n  sendDataGuaranteed(clientId, dataType, data) {\n    this.easyrtc.sendDataWS(clientId, dataType, data);\n  }\n\n  broadcastData(dataType, data) {\n    var roomOccupants = this.easyrtc.getRoomOccupantsAsMap(this.room);\n\n    // Iterate over the keys of the easyrtc room occupants map.\n    // getRoomOccupantsAsArray uses Object.keys which allocates memory.\n    for (var roomOccupant in roomOccupants) {\n      if (\n        roomOccupants[roomOccupant] &&\n        roomOccupant !== this.easyrtc.myEasyrtcid\n      ) {\n        // send via webrtc otherwise fallback to websockets\n        this.easyrtc.sendData(roomOccupant, dataType, data);\n      }\n    }\n  }\n\n  broadcastDataGuaranteed(dataType, data) {\n    var destination = { targetRoom: this.room };\n    this.easyrtc.sendDataWS(destination, dataType, data);\n  }\n\n  getConnectStatus(clientId) {\n    var status = this.easyrtc.getConnectStatus(clientId);\n\n    if (status == this.easyrtc.IS_CONNECTED) {\n      return NAF.adapters.IS_CONNECTED;\n    } else if (status == this.easyrtc.NOT_CONNECTED) {\n      return NAF.adapters.NOT_CONNECTED;\n    } else {\n      return NAF.adapters.CONNECTING;\n    }\n  }\n\n  getMediaStream(clientId) {\n    var that = this;\n    if (this.audioStreams[clientId]) {\n      NAF.log.write(\"Already had audio for \" + clientId);\n      return Promise.resolve(this.audioStreams[clientId]);\n    } else {\n      NAF.log.write(\"Waiting on audio for \" + clientId);\n      return new Promise(function(resolve) {\n        that.pendingAudioRequest[clientId] = resolve;\n      });\n    }\n  }\n\n  disconnect() {\n    this.easyrtc.disconnect();\n  }\n\n  /**\n   * Privates\n   */\n\n  _storeAudioStream(easyrtcid, stream) {\n    this.audioStreams[easyrtcid] = stream;\n    if (this.pendingAudioRequest[easyrtcid]) {\n      NAF.log.write(\"got pending audio for \" + easyrtcid);\n      this.pendingAudioRequest[easyrtcid](stream);\n      delete this.pendingAudioRequest[easyrtcid](stream);\n    }\n  }\n\n  _connect(audioEnabled, connectSuccess, connectFailure) {\n    var that = this;\n\n    this.easyrtc.setStreamAcceptor(this._storeAudioStream.bind(this));\n\n    this.easyrtc.setOnStreamClosed(function(easyrtcid) {\n      delete that.audioStreams[easyrtcid];\n    });\n\n    if (audioEnabled) {\n      this.easyrtc.initMediaSource(\n        function() {\n          that.easyrtc.connect(that.app, connectSuccess, connectFailure);\n        },\n        function(errorCode, errmesg) {\n          NAF.log.error(errorCode, errmesg);\n        }\n      );\n    } else {\n      that.easyrtc.connect(that.app, connectSuccess, connectFailure);\n    }\n  }\n\n  _getRoomJoinTime(clientId) {\n    var myRoomId = NAF.room;\n    var joinTime = this.easyrtc.getRoomOccupantsAsMap(myRoomId)[clientId]\n      .roomJoinTime;\n    return joinTime;\n  }\n\n  getServerTime() {\n    return Date.now() + this.avgTimeOffset;\n  }\n}\n\nNAF.adapters.register(\"easyrtc\", EasyRtcAdapter);\n\nmodule.exports = EasyRtcAdapter;\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}